---
layout: post
title: "从输入一个url到展示到页面上发生了什么？"
date: 2022-04-10 15:50
comments: true
tags: 
	- 面试 
	- 计算机网络
---

> 世界上的确没有“如果”，不过却有很多“但是”

<!-- more -->

## **一、简介**

为什么你输入这个网站的 url，就可以看到这个网站的内容呢
说实话，这个问题概括的点真的足够多，甚至每一个点都可以单独问很多很多，我先将自己最近学习理解的一些整体记下来，之后有时间再仔细学习其中的每一个点

## **二、流程**

- 输入 url
- 查找强缓存
- DNS 域名解析
- TCP 三次握手
- 发送 http 请求
- 浏览器解析渲染页面
- TCP 四次挥手断开连接

## **三、详细**

#### 1）输入 url

用户在浏览器中输入内容，浏览器会（使用的是浏览器进程）进行判断，判断是否 url，如果不是完整的 url 就会当成搜索内容，进行合成，合成一个合法的 url，然后走搜索的 url，如果是完整的 url，那么进行请求访问，

##### 什么是 url

在 WWW 上，每一信息资源都有统一的且在网上唯一的地址，该地址就叫 URL（Uniform Resource Locator,统一资源定位器），它是 WWW 的统一资源定位标志，就是指网络地址。

> URL 由三部分组成：资源类型、存放资源的主机域名、资源文件名
> 可认为由 4 部分组成：协议、主机、端口、路径
> 例如：`https://wwww.baidu.com:80/search`(地址我随便定义的)

#### 2）查找强缓存

浏览器构建请求之后，会先检查强缓存，如果命中强缓存，就直接使用，否则就进行 DNS 域名解析

##### 强缓存

强缓存属于浏览器缓存，浏览器缓存包括强缓存和协商缓存
强缓存：直接从本地缓存读取，不去请求服务器，返回的状态码是 200

> 强缓存主要包括 expires 和 cache-control
>
> - expries: expires 是 HTTP1.0 中定义的缓存字段。是一个时间戳，当我们请求一个资源，服务器返回时，可以在 Response Headers 中增加 expires 字段表示资源的过期时间。
> - cache-control：由于 expries 存在问题（客户端和服务端存在时间差异，并且客户端的时间是可以更改的），所以 HTTP1.1 新增了 cache-control 字段解决，当 cache-control 和 expires 都存在时，cache-control 优先级更高。该字段是一个时间长度，单位秒，表示该资源过了多少秒后失效。当客户端请求资源的时候，发现该资源还在有效时间内则使用该缓存，不依赖客户端时间。（比如设置 max-age，此时时间不依托客户端时间）
> - pragma：no-cache （pragma -> cache-control -> expires）
>   pragma 是一个在 HTTP1.0 中规定的通用首部，它用来向后兼容只支持 HTTP1.0 协议的缓存服务器，那时候 HTTP1.1 协议中的 Cache-Control 还没有出来。（注意：由于 Pragma 在 HTTP 响应中的行为没有确切规范，所以不能可靠替代 HTTP/1.1 中通用首部 Cache-Control，尽管在请求中，假如 Cache-Control 不存在的话，它的行为与 Cache-Control: no-cache 一致。建议只在需要兼容 HTTP/1.0 客户端的场合下应用 Pragma 首部。）（MDN 表述）

说起缓存不止包括浏览器缓存，这里涉及的点不少，之后再详细编写文档吧

#### 3)DNS 解析

说起 DNS，首先要说明一个两个概念，一个是域名，一个是 ip 地址

- 域名： 我们输入的www.baidu.com就是域名
- ip 地址：是 ip 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。
  而数据包是通过 IP 地址传给对方的。我们需要一个系统将域名转换为 ip 地址，这个系统就叫做 DNS（域名系统）。得到 ip 这一步骤就是 DNS 解析。
  浏览器有 DNS 缓存的功能的（即将已经解析过的域名和其对应的 ip 地址进行缓存）
- 域名解析：DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。

##### DNS 解析工作方式

先实现**递归查询**（即客户端和浏览器、本地的 DNS），后**迭代查询**（本地 DNS 服务器与根域等等）
浏览器、操作系统、路由器都会缓存一些 URL 对应的 IP 地址，统称为 DNS 高速缓存。这是为了加快 DNS 解析速度，使得不必每次都到根域名服务器中去查询。

- 查询浏览器缓存
- 系统缓存查询，操作系统查看本地 hosts 文件是否对应着 ip 地址
- 路由器缓存查询（路由器也存在 DNS 缓存）
- 本地 DNS 服务器缓存
  以上都是递归查询（即任何一步找到都会结束查找流程）
  下面的是迭代查询（迭代是不会自己去查询 ip，而是查找相关的服务器 IP 地址返回给客户端，客户端会不断的向这些服务器进行查询，直到查询到了位置），例如查询www.baidu.com
- 本地 DNS 服务器查询根域名服务器，该过程并不会返回映射关系，告诉本地 DNS 服务器去顶级域名服务器查询
- 本地 DNS 服务器查询顶级域名服务器(即 com 服务器)，同样不会返回映射关系，只会引导你去二级域名服务器查询
- 本地 DNS 服务器查询二级域名服务器(即 baidu.com 服务器)，此时已经是最后一级了，如果有则返回映射关系。

- 拿到 ip 后传给本地的 DNS，然后返回给电脑，也会进行缓存

#### 4)TCP 三次握手

- 客户端发送一个带 SYN=1，Seq=X 的数据包到服务器端口， 客户端进入 SYN_SEND 状态（SYN 同步位 SYN=1 表示进行一个链接请求 ｜ seq 序号 随机的）
  （客户端发送位码为 SYN ＝ 1 的 TCP 包给服务器，并且随机产生一个作为序列号，服务器接收）

- 服务器发回一个带 SYN=1， ACK=1， Seq=Y， ack=X + 1 的响应包以示传达确认信息，服务器进入到 SYN-RCVD 状态（ACK 确认位 ACK=1 确认有效 ACK=0 确认无效 ｜ ack 确认号 对方发送的 序号+1）
  （服务器收到请求后，向客户端发送确认号（即客户端发来的序列号（seq）加一），SYN=1，序列号随机数（Seq）和确认有效的 ACK=1）

- 客户端再回传一个带 ACK=1，ack= Y + 1 的数据包，代表握手成功
  （客户端拿到后检查确认号是否正确，即第一次发送的序列号+1 了，以及确认有效（ACK）是否为 1，若正确，客户端会再发送确认号(服务器的序列号（Seq）+1)，确认有效为 1
  ![tcp](../../../assets/demo/page/tcp.webp)、

> TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。
> 发送的过程中还有一个优化策略，就是把大的数据包拆成一个个小包，依次传输到接收方，接收方按照这个小包的顺序把它们组装成完整数据包。这一步也保证了 TCP 安全链接的一部分（数据校验）

#### 5)发送 http 请求

- 开始发送 HTTP 请求报文。请求报文由请求行（request line）、请求头（header）、请求体三个部分组成
  客户端像浏览器发送请求行
- 这里如果服务端返回 304，此时就使用协商缓存
  协商缓存依托于强缓存，即从浏览器缓存中获取

```js
// 请求方法是GET，路径为根路径，HTTP协议版本为1.1
GET / HTTP / 1.1;
```

也会带上请求头，请求头中存在一些属性，关于浏览器缓存，接受信息，编码格式等等
最后是请求体，请求体只有在 POST 方法下存在

- 服务器接收请求信息，然后返回响应行、相应头、相应体
  响应行

```js
HTTP/1.1 200 OK
```

响应头，响应头包含了服务器返回的一些数据（比如内容类型、日期等等）

- 响应完成之后，要判断 Connection 字段, 如果请求头或响应头中包含 Connection: Keep-Alive，表示建立了持久连接，这样 TCP 连接会一直保持，之后请求统一站点的资源会复用这个连接。否则断开 TCP 连接, 请求-响应流程结束。
  **下面这个图片我看看有一篇文章很不错，看着很清晰**
  ![流程](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/12/15/16f080b095268038~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

> 协商缓存：
>
> 1. Last-Modified: 服务器返回 Last-Modified 指出最后修改时间，下一次请求在请求头上加 If-Modified-Since 作比较，没有修改返回 304， 问题是时间精确到秒，1s 内文件多次修改可能有问题
> 2. Etag : 服务器返回 Etag 指定唯一标识，资源发生改变的时候，这个值也会发生改变， 下一次请求请求头上添加 If-None-Match，服务器作比较，这种更精确

> 说实话这里也有考点，比如比较常用的请求头，响应头都有哪些，restful 风格接口还有常见的状态码等等

#### 6)浏览器解析渲染页面

主要流程如下：(此时交给了渲染器进程：合成器线程、栅格化线程)

1. 根据 HTML 文件解析出 DOM 树
2. 根据 CSS 解析出 CSS 规则树
3. 将 DOM 树和 CSS 规则树合并，构建成渲染树
4. reflow(重排)：根据渲染树进行节点信息计算
5. repaint(重绘)：根据计算好的信息绘制整个页面

> 有一说一，这里可以扩展的太多，从浏览器构成到渲染流程再到用到的一些算法，这里我过多概述，之后重新写一篇文章讲述（看别人写的文章，感觉这里知识点好多）

#### 7)TCP 四次挥手断开连接

主要流程如下：（FIN：终结报文、ACK：响应报文）

1. 客户端发送一个 tcp 首部 FIN 为 1 的终结报文，客户端进入 FIN_WAIT_1 的状态
2. 服务器接收到报文后，发送一个 ACK 响应报文，然后进入到 CLOSED_WAIT 的状态
3. 客户端接收到 ACK 响应报文后，进入到 FIN_WAIT_2 状态
4. 服务器处理完数据向客户端发送 FIN 报文，然后服务器进入到 LAST_ACK 的状态
5. 客户端收到服务端的 FIN 报文后，回一个 ACK 应答报文，之后进入 TIME_WAIT 状态
6. 服务器收到了 ACK 应答报文后，就进入了 CLOSED 状态，至此服务端已经完成连接的关闭。
7. 客户端在经过 2MSL 一段时间后，自动进入 CLOSED 状态，至此客户端也完成连接的关闭。

**下面这个图片我看看有一篇文章很不错，看着很清晰**
![Tcp四次挥手流程](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0e0aa33202914929aef538432fece844~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

**常见问题**

1. 为什么需要四次挥手
   因为当客户端发送断开连接的 FIN 报文后，服务器此时可能还在继续发数据，需要等服务器处理完或者发送完，才会告诉客户端可以的结束的 FIN 报文
2. 为什么客户端在 TIME-WAIT 阶段要等 2MSL？
   先得说一下，MSL 是一段 TCP 在传输的过程中最大的生命周期
   最后一次挥手是下面这样一个流程：
   - 客户端发送 ACK 响应报文之后，会等待 2MSL
   - 服务器在 1MSL 时没有收到客户端的 ACK 响应报文，就会重新发送 FIN 报文
   - 而客户端发完 ACK 报文后，在 2MSL 内没有收到服务器发的 FIN 报文，就说明传输成功
   - 如果客户端又收到了 ACK 报文，就说明 ACK 响应报文没有送到，会再次发送 ACK 报文，继续等待 2MSL

记住一点，客户端和服务端都可以先发送 FIN 终结报文

#####

##**五、参考资料**
[“三次握手，四次挥手”这么讲，保证你忘不了](https://juejin.cn/post/6965544021833809928)  
[(1.6w 字)浏览器灵魂之问，请问你能接得住几个？](https://juejin.cn/post/6844904021308735502#heading-24)
[细说浏览器输入 URL 后发生了什么](https://juejin.cn/post/6844904054074654728)  
[从 URL 输入到页面展现到底发生什么？](https://juejin.cn/post/6844903784229896199)

#####

**有哪里写的不对欢迎指正，github 提 issues（暂时还没想好怎么处理，暂时 issues 吧）**
